<!DOCTYPE html>
<!-- http://bl.ocks.org/mbostock/1125997
This animation demonstrates the use of transition.transition to create chained transitions. Chained transitions inherit the reference time of the original transition, guaranteeing synchronicity. Furthermore, since initial transitions are created within the context of transition.each the circles are precisely synchronized. -->
<head>
  <meta charset="utf-8">
  <script src="http://d3js.org/d3.v3.min.js"></script>         <!-- Load the d3 library -->
  <link href="../taste.css" rel="stylesheet" media="screen">      <!-- Taste of D3's CSS; you can get rid of it in your version -->
  <style>
    circle {
      fill: #000;
      stroke: #000;
      stroke-width: 1.5px;
    }
  </style>
</head>
<body>
<h1>Chained Transitions</h1>
<p> Based on Mike Bostock's  <a href="http://bl.ocks.org/mbostock/1125997">http://bl.ocks.org/mbostock/1125997</a>,
mostly tweaked to make it easier for beginners to understand.</p>

<svg width="960" height="600"></svg>        <!-- SVG graphics will go here  -->

<script type="text/javascript">
// Set the parameters
var fromColor = "Purple", toColor = "orange", numberOfColors = 10,
    numberOfCircles = 50,
    circleRadius = 25,
    delayBetweenCircles = 70, SpacingBetweenCircleCenters = 10.2,
    width = 880, height = 500;

// Create a margin so the circles don't get clipped
var svg = d3.select("svg").append("g")
  .attr("transform", "translate(40, 40)");

// Create a scale of colors that transition from fromColor to toColor
var circleColors = d3.scale.linear()
    .domain([numberOfColors, 0])
    .range([fromColor, toColor])
    .interpolate(d3.interpolateHcl);  //Research interpolation

svg.selectAll("circle")
    .data(d3.range(numberOfCircles))     // Has an array of 0, 1, 2...
  .enter().append("circle")
    .attr("r", circleRadius)
    .attr("cx", 0)
    .attr("cy", function(d,i) {return d * SpacingBetweenCircleCenters})
    .style("fill", function(d) { return circleColors(d % numberOfColors); })
  .transition()
    .duration(2500)
    .delay(function(d,i) { return d * delayBetweenCircles; })
    .each(slide);


function slide() {
  var circle = d3.select(this);

  function repeat() {
    // console.log("repeat", circle);
    circle = circle.transition()
        .attr("cx", width)
      .transition()
        .attr("cx", 0)
        .each("end", repeat);
  };
  repeat();
  // NOTE: check with D3 Google groups to make sure that this is actually the same as using parentheses around the function
}
</script>




</body>
</html>
